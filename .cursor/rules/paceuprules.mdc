---
alwaysApply: true
---


You are an expert in Flutter, Dart, Riverpod, Freezed, Flutter Hooks, and MySQL.

Key Principles
- Write concise, technical Dart code with accurate examples.
- Use functional and declarative programming patterns where appropriate.
- Prefer composition over inheritance.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported widget, subwidgets, helpers, static content, types.

Dart/Flutter
- Use const constructors for immutable widgets.
- Leverage Freezed for immutable state classes and unions.
- Use arrow syntax for simple functions and methods.
- Prefer expression bodies for one-line getters and setters.
- Use trailing commas for better formatting and diffs.

Error Handling and Validation
- Implement error handling in views using SelectableText.rich instead of SnackBars.
- Display errors in SelectableText.rich with red color for visibility.
- Handle empty states within the displaying screen.
- Use AsyncValue for proper error handling and loading states.

Riverpod-Specific Guidelines
- Use @riverpod annotation for generating providers.
- Prefer AsyncNotifierProvider and NotifierProvider over StateProvider.
- Avoid StateProvider, StateNotifierProvider, and ChangeNotifierProvider.
- Use ref.invalidate() for manually triggering provider updates.
- Implement proper cancellation of asynchronous operations when widgets are disposed.

Performance Optimization
- Use const widgets where possible to optimize rebuilds.
- Implement list view optimizations (e.g., ListView.builder).
- Use AssetImage for static images and cached_network_image for remote images.
- Implement proper error handling for Supabase operations, including network errors.

Key Conventions
1. Use GoRouter or auto_route for navigation and deep linking.
2. Optimize for Flutter performance metrics (first meaningful paint, time to interactive).
3. Prefer stateless widgets:
   - Use ConsumerWidget with Riverpod for state-dependent widgets.
   - Use HookConsumerWidget when combining Riverpod and Flutter Hooks.

UI and Styling
- Use Flutter's built-in widgets and create custom widgets.
- Implement responsive design using LayoutBuilder or MediaQuery.
- Use themes for consistent styling across the app.
- Use Theme.of(context).textTheme.titleLarge instead of headline6, and headlineSmall instead of headline5 etc.

Widgets and UI Components
- Create small, private widget classes instead of methods like Widget _build....
- Implement RefreshIndicator for pull-to-refresh functionality.
- In TextFields, set appropriate textCapitalization, keyboardType, and textInputAction.
- Always include an errorBuilder when using Image.network.

Miscellaneous
- Use log instead of print for debugging.
- Use Flutter Hooks / Riverpod Hooks where appropriate.
- Keep lines no longer than 80 characters, adding commas before closing brackets for multi-parameter functions.

Documentation
- Follow official Flutter, Riverpod, and MySQL documentation for best practices.

Refer to Flutter, Riverpod, and MySQL documentation for Widgets, State Management, and Backend Integration best practices.

## ── Technology & Structure
- App: Flutter (package id: com.example.paceup), Android + iOS.
- Main packages: flutter_map, persistent_bottom_nav_bar_v2, image_picker, http.
- Backend: PHP/MySQL with clean UTF-8 JSON API (no BOM, no stray spaces).
- Android: MethodChannel 'paceup/route' (getLatestRoute, getExerciseRoute).  

## ── Design System (DO NOT CHANGE without explicit approval)
- Font: Inter (400 / 500 / 600) already connected in pubspec.yaml.  
- USE ONLY tokens from AppTheme, AppColors, AppTextStyles, AppRadius.  
- NEVER introduce custom padding, radius, or color values.  
- Follow iOS-style UX: swipe-back navigation, segmented controls, compact AppBar, BouncingScrollPhysics.  
- Ensure proper SafeArea and adaptive layouts for all screens.  

## ── Code Style & Comments
- ALWAYS add `const` where possible.  
- WRITE detailed Russian comments explaining every block.  
- Large sections must be visually framed with divider comments (e.g. “────────────”).  
- Maintain architectural cleanliness, testability, and clear structure.  
- Indicate potential performance risks and improvements after each patch.  

## ── Performance & UX
- AVOID jank, heavy rebuilds, or unnecessary animations.  
- ALWAYS suggest 1–2 cheap performance fixes in patches.  
- USE smooth transitions and light animations.  
- Prefetch heavy images and minimize redundant HTTP requests.  
- Keep feed smooth and responsive.  

## ── Feed & Pagination
- Feed uses cursor-based pagination.  
- Deduplicate by id via `_seenIds`.  
- Soft refresh: update items without full rebuild or scroll jump.  
- Prefetch media when possible.  

## ── API Contracts & Data
- Field names and types are **STABLE**.  
  DO NOT rename or change types without explicit approval.  
- Backend returns clean UTF-8 JSON (no BOM).  
- Any DB changes must include a separate SQL migration script. 

## ── Map & Routes
- Widget `multi_route_card`: static OSM map.  
- Fit bounds after `onReady`.  
- Polyline color = AppColors.brandPrimary, strokeWidth = 3. 

## ── Refactoring & Edits
- **Surgical edits only:** When changing existing files, use minimal, targeted edits (e.g. search_replace with a small `old_string`/`new_string`). NEVER overwrite the entire file (e.g. via `write`) to change one line, a few lines, or an import — this wastes tokens and produces huge diffs (−2000+ lines).
- NEVER modify visuals unless the task explicitly requires it.  
- For performance changes: briefly describe the expected effect.  
- For API-related changes: separate them clearly and flag for review.  

## ── Output & Deliverables
- New widgets or utilities must follow existing architecture.  
- Suggest small, high-impact performance optimizations (e.g. const constructors, memoization, proper keys, avoiding setState in build).  
